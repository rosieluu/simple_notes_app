import { query, mutation, internalQuery } from "./_generated/server";
import { v } from "convex/values";
import { getAuthUserId } from "@convex-dev/auth/server";
import { api } from "./_generated/api";

export const list = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }
    
    return await ctx.db
      .query("notes")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .order("desc")
      .collect();
  },
});

export const search = query({
  args: { 
    query: v.string(),
    tag: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }

    if (args.tag) {
      // Filter by tag
      const allNotes = await ctx.db
        .query("notes")
        .withIndex("by_user", (q) => q.eq("userId", userId))
        .collect();
      
      return allNotes.filter(note => 
        note.tags.includes(args.tag!) &&
        (args.query === "" || 
         (note.title && note.title.toLowerCase().includes(args.query.toLowerCase())) ||
         (note.content && note.content.toLowerCase().includes(args.query.toLowerCase())))
      );
    }

    if (args.query === "") {
      return await ctx.db
        .query("notes")
        .withIndex("by_user", (q) => q.eq("userId", userId))
        .order("desc")
        .collect();
    }

    // Search in title and content
    const titleResults = await ctx.db
      .query("notes")
      .withSearchIndex("search_title", (q) =>
        q.search("title", args.query).eq("userId", userId)
      )
      .collect();

    const contentResults = await ctx.db
      .query("notes")
      .withSearchIndex("search_content", (q) =>
        q.search("content", args.query).eq("userId", userId)
      )
      .collect();

    // Combine and deduplicate results
    const allResults = [...titleResults, ...contentResults];
    const uniqueResults = allResults.filter((note, index, self) =>
      index === self.findIndex(n => n._id === note._id)
    );

    return uniqueResults.sort((a, b) => b._creationTime - a._creationTime);
  },
});

export const getAllTags = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }

    const notes = await ctx.db
      .query("notes")
      .withIndex("by_user", (q) => q.eq("userId", userId))
      .collect();

    const allTags = notes.flatMap(note => note.tags);
    const uniqueTags = [...new Set(allTags)];
    
    return uniqueTags.sort();
  },
});

// Query pour rÃ©cupÃ©rer les informations de l'utilisateur connectÃ©
export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }

    // RÃ©cupÃ©rer les informations utilisateur depuis la table users
    const user = await ctx.db.get(userId);
    
    return {
      id: userId,
      name: user?.name || null,
      email: user?.email || null,
      isAnonymous: user?.isAnonymous || false,
    };
  },
});

// Query pour rÃ©cupÃ©rer une note par ID (nÃ©cessaire pour l'action de gÃ©nÃ©ration d'image)
export const getById = query({
  args: { id: v.id("notes") },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return null;
    }

    const note = await ctx.db.get(args.id);
    if (!note || note.userId !== userId) {
      return null;
    }

    return note;
  },
});

// Query interne pour rÃ©cupÃ©rer une note par ID sans authentification (pour les actions programmÃ©es)
export const getByIdInternal = internalQuery({
  args: { id: v.id("notes"), userId: v.id("users") },
  handler: async (ctx, args) => {
    const note = await ctx.db.get(args.id);
    if (!note || note.userId !== args.userId) {
      return null;
    }
    return note;
  },
});

export const create = mutation({
  args: {
    title: v.optional(v.string()),
    content: v.optional(v.string()),
    tags: v.array(v.string()),
    imageIds: v.optional(v.array(v.id("_storage"))),
    autoGenerateImage: v.optional(v.boolean()), // Nouveau : dÃ©clencher auto-gÃ©nÃ©ration
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    // Prompt par dÃ©faut si le contenu est vide ou null
    const DEFAULT_PROMPT = "Enhance this real-estate photo to make it look bright, clean, modern and professional";
    
    let finalContent = args.content;
    let defaultPrompt = undefined;
    
    // Si pas de contenu, utiliser le prompt par dÃ©faut
    if (!args.content || args.content.trim() === "") {
      finalContent = DEFAULT_PROMPT;
      defaultPrompt = DEFAULT_PROMPT;
    }

    // GÃ©nÃ©rer les URLs des images si des imageIds sont fournis
    let imageUrls: string[] = [];
    if (args.imageIds && args.imageIds.length > 0) {
      // Limiter Ã  3 images maximum
      const limitedImageIds = args.imageIds.slice(0, 3);
      
      for (const imageId of limitedImageIds) {
        const url = await ctx.storage.getUrl(imageId);
        if (url) {
          imageUrls.push(url);
        }
      }
    }

    // 1. CrÃ©er la note d'abord
    const noteId = await ctx.db.insert("notes", {
      title: args.title || "Untitled Note",
      content: finalContent,
      tags: args.tags,
      userId,
      imageIds: args.imageIds?.slice(0, 3), // Limiter Ã  3 images
      imageUrls: imageUrls.length > 0 ? imageUrls : undefined,
      hasImages: args.imageIds && args.imageIds.length > 0,
      defaultPrompt,
      generatedPrompt: undefined, // Sera rempli aprÃ¨s gÃ©nÃ©ration
    });

    // 2. DÃ©clencher la gÃ©nÃ©ration d'image en arriÃ¨re-plan (si activÃ©e)
    if (args.autoGenerateImage !== false) { // Par dÃ©faut = true
      // Programmer la gÃ©nÃ©ration d'image de maniÃ¨re asynchrone
      // Note: On utilisera une approche diffÃ©rente pour Ã©viter les erreurs de rÃ©fÃ©rence
      console.log(`ðŸŽ¨ Note crÃ©Ã©e ${noteId} - gÃ©nÃ©ration d'image prÃ©vue`);
      // TODO: ImplÃ©menter la gÃ©nÃ©ration automatique via webhook ou action sÃ©parÃ©e
    }

    return noteId;
  },
});

export const update = mutation({
  args: {
    id: v.id("notes"),
    title: v.optional(v.string()),
    content: v.optional(v.string()),
    tags: v.array(v.string()),
    imageIds: v.optional(v.array(v.id("_storage"))),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const note = await ctx.db.get(args.id);
    if (!note || note.userId !== userId) {
      throw new Error("Note not found or not authorized");
    }

    // Prompt par dÃ©faut si le contenu est vide
    const DEFAULT_PROMPT = "Enhance this real-estate photo to make it look bright, clean, modern and professional";
    
    let finalContent = args.content;
    let defaultPrompt = undefined;
    
    if (!args.content || args.content.trim() === "") {
      finalContent = DEFAULT_PROMPT;
      defaultPrompt = DEFAULT_PROMPT;
    }

    // GÃ©nÃ©rer les URLs des images si des imageIds sont fournis
    let imageUrls: string[] = [];
    if (args.imageIds && args.imageIds.length > 0) {
      const limitedImageIds = args.imageIds.slice(0, 3);
      
      for (const imageId of limitedImageIds) {
        const url = await ctx.storage.getUrl(imageId);
        if (url) {
          imageUrls.push(url);
        }
      }
    }

    return await ctx.db.patch(args.id, {
      title: args.title || "Untitled Note",
      content: finalContent,
      tags: args.tags,
      imageIds: args.imageIds?.slice(0, 3),
      imageUrls: imageUrls.length > 0 ? imageUrls : undefined,
      hasImages: args.imageIds && args.imageIds.length > 0,
      defaultPrompt,
    });
  },
});

export const remove = mutation({
  args: {
    id: v.id("notes"),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const note = await ctx.db.get(args.id);
    if (!note || note.userId !== userId) {
      throw new Error("Note not found or not authorized");
    }

    // Supprimer les images associÃ©es si elles existent
    if (note.imageIds && note.imageIds.length > 0) {
      for (const imageId of note.imageIds) {
        await ctx.storage.delete(imageId);
      }
    }

    return await ctx.db.delete(args.id);
  },
});

// Nouvelle fonction pour gÃ©nÃ©rer l'URL d'upload
export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }
    
    return await ctx.storage.generateUploadUrl();
  },
});

// Nouvelle fonction pour obtenir l'URL d'une image
export const getImageUrl = query({
  args: { imageId: v.id("_storage") },
  handler: async (ctx, args) => {
    return await ctx.storage.getUrl(args.imageId);
  },
});

// Nouvelle fonction pour lister les notes avec images
export const listWithImages = query({
  args: {},
  handler: async (ctx) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      return [];
    }
    
    return await ctx.db
      .query("notes")
      .withIndex("by_user_with_images", (q) => 
        q.eq("userId", userId).eq("hasImages", true)
      )
      .order("desc")
      .collect();
  },
});

// Mutation pour dÃ©clencher la gÃ©nÃ©ration d'image aprÃ¨s crÃ©ation de note
// Action pour dÃ©clencher la gÃ©nÃ©ration avec OpenRouter + Context7
export const triggerImageGenerationOpenRouter = mutation({
  args: { 
    noteId: v.id("notes"),
    style: v.optional(v.string()),
    aspectRatio: v.optional(v.string()),
    useContext7: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    console.log(`ðŸŽ¨ triggerImageGenerationOpenRouter - userId: ${userId}, noteId: ${args.noteId}`);

    const note = await ctx.db.get(args.noteId);
    if (!note || note.userId !== userId) {
      throw new Error("Note not found or not authorized");
    }

    // Marquer que la gÃ©nÃ©ration est en cours
    await ctx.db.patch(args.noteId, {
      generatedPrompt: "ðŸŽ¨ GÃ©nÃ©ration en cours avec OpenRouter + Gemini 2.5 Flash...",
    });

    try {
      // Programmer l'action OpenRouter + Gemini 2.5 Flash Image
      await ctx.scheduler.runAfter(0, api.imageGenerationOpenRouter.generateImageFromNoteOpenRouter, {
        noteId: args.noteId,
        userId: userId,
        style: args.style || "photorealistic",
        aspectRatio: args.aspectRatio || "1:1",
        useContext7: args.useContext7 !== false,
      });
      
      console.log(`âœ… GÃ©nÃ©ration Gemini 2.5 Flash Image programmÃ©e pour note ${args.noteId}`);
      return { 
        success: true, 
        message: "GÃ©nÃ©ration d'image avec Gemini 2.5 Flash Image via OpenRouter programmÃ©e",
        useContext7: args.useContext7 !== false
      };
    } catch (error) {
      console.error("Erreur programmation OpenRouter:", error);
      await ctx.db.patch(args.noteId, {
        generatedPrompt: undefined,
      });
      throw error;
    }
  },
});// Mutation pour ajouter une image gÃ©nÃ©rÃ©e Ã  une note existante
// Mutation publique pour ajouter une image gÃ©nÃ©rÃ©e (avec auth)
export const addGeneratedImage = mutation({
  args: {
    noteId: v.id("notes"),
    imageId: v.id("_storage"),
    prompt: v.string(),
  },
  handler: async (ctx, args) => {
    const userId = await getAuthUserId(ctx);
    if (!userId) {
      throw new Error("Not authenticated");
    }

    const note = await ctx.db.get(args.noteId);
    if (!note || note.userId !== userId) {
      throw new Error("Note not found or not authorized");
    }

    // GÃ©nÃ©rer l'URL pour l'image stockÃ©e
    const imageUrl = await ctx.storage.getUrl(args.imageId);
    if (!imageUrl) {
      throw new Error("Failed to generate image URL");
    }

    // Ajouter l'image gÃ©nÃ©rÃ©e Ã  la note
    const currentImageIds = note.imageIds || [];
    const currentImageUrls = note.imageUrls || [];

    await ctx.db.patch(args.noteId, {
      imageIds: [...currentImageIds, args.imageId],
      imageUrls: [...currentImageUrls, imageUrl],
      hasImages: true,
      generatedPrompt: args.prompt,
    });

    console.log(`âœ… Image ajoutÃ©e Ã  la note ${args.noteId}: ${imageUrl}`);
  },
});

// Mutation interne pour ajouter une image gÃ©nÃ©rÃ©e (sans auth, appelÃ©e par actions)
export const addGeneratedImageInternal = mutation({
  args: {
    noteId: v.id("notes"),
    userId: v.id("users"),
    imageId: v.id("_storage"),
    prompt: v.string(),
  },
  handler: async (ctx, args) => {
    const note = await ctx.db.get(args.noteId);
    if (!note || note.userId !== args.userId) {
      throw new Error("Note not found or not authorized");
    }

    // GÃ©nÃ©rer l'URL pour l'image stockÃ©e
    const imageUrl = await ctx.storage.getUrl(args.imageId);
    if (!imageUrl) {
      throw new Error("Failed to generate image URL");
    }

    // Ajouter l'image gÃ©nÃ©rÃ©e Ã  la note
    const currentImageIds = note.imageIds || [];
    const currentImageUrls = note.imageUrls || [];

    await ctx.db.patch(args.noteId, {
      imageIds: [...currentImageIds, args.imageId],
      imageUrls: [...currentImageUrls, imageUrl],
      hasImages: true,
      generatedPrompt: args.prompt,
    });

    console.log(`âœ… Image ajoutÃ©e Ã  la note ${args.noteId}: ${imageUrl}`);
  },
});
